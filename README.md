# Info

1. Проектная задача **Bank API**. Требуется реализовать веб-сервис, реализующий логику работы клиентов
с банковскими счетами. API Физического лица (клиента) должно позволять выполнять следующие действия по счетам:  

       Выпуск новой карты по счету
       Проcмотр списка карт
       Внесение вредств
       Проверка баланса  

Подробное условие задачи в файле **files/task.pdf**.

2. Использована БД **Postgres** в контейнере **Docker**. Настройки см. в файле **docker-compose.yaml**.

3. Зависимости лучше внедрять через конструктор в final поля. Так в будущем будет проще тестировать 
  классы unit тестами, т.к все нужные зависимости можно будет передать через конструктор, 
  а в случае с внедрение в поле, так не получится. Так же так нельзя будет использовать класс, 
  не передав в него нужные зависимости.

       public class ClientController {
           
           private final ClientService clientService;
           
           @Autowired
           public ClientController(ClientService clientService) {
               this.clientService = clientService;
           }
           
       }   

3. **http://localhost:8082/h2-console** - консоль базы данных **H2**:  
JDBC URL: jdbc:h2:mem:bank;MODE=PostgreSQL  
User Name: sa  
Password: <пустой>
4. Данные в базу добавлены с помощью **Flyway**. 
5. **http://localhost:8082/swagger-ui/index.html** - документация к API (сгенерирована с помощью **Swagger**).
6. **http://localhost:8082/** - открыть приложение (фронтэнд начал делать на **AngularJS**).
7. Изначально проверка API осуществлялась с помощью **Postman**. Затем были написаны **интеграционные тесты** и **юнит-тесты**.
8. Для тестирования используется тестовый **профиль** со своей базой данных.

# TODO list
- Доделать оставшийся функционал по заданию.
- Исправить замечания после код-ревью. Замечания сохранил в файле **task/Замечания.rtf**.

# Замечания
Есть пара коментов:  

1) Зависимости лучше внедрять через конструктор в final поля. Так в будущем будет проще тестировать 
классы unit тестами, т.к все нужные зависимости можно будет передать через конструктор, 
а в случае с внедрение в поле, так не получится. Так же так нельзя будет использовать класс, 
не передав в него нужные зависимости.

2) Ошибки в ответах лучше не в контроллере формировать. Лучше кинуть исключение из сервиса, 
а на сетевом слое добавить @ExceptionHandler, в том числе на все неизвестные 
ошибки (на все RuntimeException), чтобы всегда отправлять клиенту один и тот же формат ответа.

3) В entity нет поля version. Нужно учитывать, что все клиентские приложения работают в многопоточной среде, 
и одна и та же сущность может меняться из разных сред. Нужно озаботиться блокировками, 
а через version Hibernate может это делать из коробки.

4) В БД на все foreign key и все поля поиска нужно добавить индексы для ускорения чтения.
